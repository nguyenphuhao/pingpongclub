// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTH
// ============================================

model User {
  id    String  @id @default(cuid())
  email String  @unique
  phone String? @unique

  // Firebase UID (if using Firebase Auth)
  firebaseUid String? @unique @map("firebase_uid")

  // Auth Provider (google.com, facebook.com, password, phone)
  provider String? // Firebase sign-in provider or 'phone' for OTP

  // Password (hashed using bcrypt)
  password String? // Hashed password for email/phone login

  // Profile
  firstName String? @map("first_name")
  lastName  String? @map("last_name")
  avatar    String?

  // Player Profile (for Members Module)
  nickname    String? // Display name for players
  displayName String?   @map("display_name") // Full display name
  gender      Gender?
  dateOfBirth DateTime? @map("date_of_birth")

  // Player Rating & Ranking
  ratingPoints  Int @default(1000) @map("rating_points") // Current rating
  peakRating    Int @default(1000) @map("peak_rating") // Highest rating achieved
  initialRating Int @default(1000) @map("initial_rating") // Starting rating

  // Player Stats
  totalMatches  Int    @default(0) @map("total_matches")
  totalWins     Int    @default(0) @map("total_wins")
  totalLosses   Int    @default(0) @map("total_losses")
  totalDraws    Int    @default(0) @map("total_draws")
  winRate       Float? @map("win_rate") // Calculated field
  currentStreak Int    @default(0) @map("current_streak") // Win/loss streak

  // Player Experience
  yearsPlaying     Float?    @map("years_playing") // Years of playing (for rank G)
  startedPlayingAt DateTime? @map("started_playing_at")

  // Player Tags & Style
  tags      String[] @default([]) // ["singles", "doubles", "left-handed"]
  playStyle String?  @map("play_style") // "Defensive", "Offensive", "All-round"

  // Profile Settings
  profileVisibility ProfileVisibility @default(PUBLIC) @map("profile_visibility")
  showPhone         Boolean           @default(false) @map("show_phone")
  showEmail         Boolean           @default(false) @map("show_email")
  showRating        Boolean           @default(true) @map("show_rating")

  // Bio & Notes
  bio        String?
  adminNotes String? @map("admin_notes") // Only admin can see

  // Role & Status
  role   UserRole   @default(USER)
  status UserStatus @default(ACTIVE)

  // Verification
  emailVerified Boolean @default(false) @map("email_verified")
  phoneVerified Boolean @default(false) @map("phone_verified")

  // Metadata
  lastLoginAt DateTime? @map("last_login_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  deletedAt   DateTime? @map("deleted_at")

  // Relations
  refreshTokens            RefreshToken[]
  notifications            Notification[]
  devices                  Device[]
  loginHistory             LoginHistory[]
  ratingHistory            RatingHistory[]
  tournamentParticipants   TournamentParticipant[]
  tournamentParticipantMembers TournamentParticipantMember[]

  @@index([email])
  @@index([firebaseUid])
  @@index([provider])
  @@index([ratingPoints])
  @@index([status])
  @@index([nickname])
  @@map("users")
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  DELETED
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

enum ProfileVisibility {
  PUBLIC // Everyone can see
  MEMBERS // Only club members
  PRIVATE // Only admin and self
}

enum PlayerRank {
  A_STAR // > 2200
  A // 2001-2200
  B // 1801-2000
  C // 1601-1800
  D // 1401-1600
  E // 1201-1400
  F // 1001-1200
  G // 801-1000 (playing <= 1 year)
  H // <= 800 (beginners)
  UNRANKED
}

model RefreshToken {
  id     String @id @default(cuid())
  token  String @unique
  userId String @map("user_id")

  // Device & Session Info
  deviceId  String?         @map("device_id")
  platform  DevicePlatform?
  ipAddress String?         @map("ip_address")
  userAgent String?         @map("user_agent")

  expiresAt  DateTime @map("expires_at")
  lastUsedAt DateTime @default(now()) @map("last_used_at")
  createdAt  DateTime @default(now()) @map("created_at")

  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  loginHistory LoginHistory?

  @@index([userId])
  @@index([token])
  @@index([deviceId])
  @@index([userId, deviceId])
  @@map("refresh_tokens")
}

model OtpVerification {
  id String @id @default(cuid())

  // Email or Phone number
  identifier     String
  identifierType OtpIdentifierType

  // OTP Code (6 digits)
  otpCode String @map("otp_code")

  // Purpose: REGISTRATION or LOGIN
  purpose OtpPurpose

  // Status
  verified Boolean @default(false)
  attempts Int     @default(0) // Number of failed attempts

  // Expiration
  expiresAt  DateTime  @map("expires_at")
  verifiedAt DateTime? @map("verified_at")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([identifier, purpose])
  @@index([otpCode])
  @@map("otp_verifications")
}

enum OtpIdentifierType {
  EMAIL
  PHONE
}

enum OtpPurpose {
  REGISTRATION
  LOGIN
}

// ============================================
// LOGIN HISTORY
// ============================================

model LoginHistory {
  id     String @id @default(cuid())
  userId String @map("user_id")

  // Device & Platform Info
  platform    DevicePlatform
  deviceId    String?        @map("device_id")
  deviceModel String?        @map("device_model")
  osVersion   String?        @map("os_version")

  // Network Info
  ipAddress String? @map("ip_address")
  userAgent String? @map("user_agent")
  location  String? // City, Country (optional, from IP geolocation)

  // Login Method
  loginMethod LoginMethod

  // Status
  status        LoginStatus @default(SUCCESS)
  failureReason String?     @map("failure_reason")

  // Timestamps
  loginAt DateTime @default(now()) @map("login_at")

  // Relations
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  refreshToken   RefreshToken? @relation(fields: [refreshTokenId], references: [id])
  refreshTokenId String?       @unique @map("refresh_token_id")

  @@index([userId])
  @@index([loginAt])
  @@index([platform])
  @@index([status])
  @@map("login_history")
}

enum LoginMethod {
  FIREBASE
  OTP_EMAIL
  OTP_PHONE
  PASSWORD_EMAIL
  PASSWORD_PHONE
}

enum LoginStatus {
  SUCCESS
  FAILED
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id     String @id @default(cuid())
  userId String @map("user_id")

  type    NotificationType
  channel NotificationChannel

  title String
  body  String
  data  Json? // Additional data as JSON

  status NotificationStatus @default(PENDING)

  sentAt DateTime? @map("sent_at")
  readAt DateTime? @map("read_at")

  error String? // Error message if failed

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([type])
  @@map("notifications")
}

enum NotificationType {
  SYSTEM
  MARKETING
  TRANSACTIONAL
  ALERT
}

enum NotificationChannel {
  EMAIL
  SMS
  PUSH
  IN_APP
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
  READ
}

// ============================================
// DEVICES (for Push Notifications)
// ============================================

model Device {
  id     String @id @default(cuid())
  userId String @map("user_id")

  fcmToken String         @unique @map("fcm_token")
  platform DevicePlatform

  deviceId  String? @map("device_id")
  model     String?
  osVersion String? @map("os_version")

  isActive Boolean @default(true) @map("is_active")

  lastUsedAt DateTime @default(now()) @map("last_used_at")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([fcmToken])
  @@map("devices")
}

enum DevicePlatform {
  IOS
  ANDROID
  WEB
}

// ============================================
// ADMIN (Internal Admin Users for Dokifree Admin)
// ============================================

model Admin {
  id       String @id @default(cuid())
  username String @unique
  password String // Hashed password using bcrypt

  // Profile
  firstName String? @map("first_name")
  lastName  String? @map("last_name")
  email     String? @unique
  avatar    String?

  // Role & Status
  role   AdminRole   @default(ADMIN)
  status AdminStatus @default(ACTIVE)

  // Metadata
  lastLoginAt DateTime? @map("last_login_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  deletedAt   DateTime? @map("deleted_at")

  @@index([username])
  @@index([email])
  @@index([status])
  @@map("admins")
}

enum AdminRole {
  ADMIN
  MODERATOR
}

enum AdminStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  DELETED
}

// ============================================
// RATING & RANKING SYSTEM
// ============================================

model RatingHistory {
  id     String @id @default(cuid())
  userId String @map("user_id")

  // Rating change
  oldRating    Int @map("old_rating")
  newRating    Int @map("new_rating")
  ratingChange Int @map("rating_change") // Can be negative

  // Old and new rank
  oldRank PlayerRank @map("old_rank")
  newRank PlayerRank @map("new_rank")

  // Reason for change
  changeReason RatingChangeReason @map("change_reason")
  notes        String?

  // Timestamp
  changedAt DateTime @default(now()) @map("changed_at")

  // Relations
  user  User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([changedAt])
  @@map("rating_history")
}

enum RatingChangeReason {
  MATCH_WIN
  MATCH_LOSS
  MATCH_DRAW
  ADMIN_ADJUSTMENT
  INITIAL_RATING
  SEASON_RESET
}

// ============================================
// TOURNAMENTS
// ============================================

model Tournament {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name        String
  description String?
  matchFormat MatchFormat @default(SINGLE) @map("match_format")
  createdAt   DateTime @default(now()) @map("created_at")

  participants TournamentParticipant[]
  stages       Stage[]
  drawSessions DrawSession[]

  @@map("tournaments")
}

model TournamentParticipant {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tournamentId String   @map("tournament_id") @db.Uuid
  userId       String?  @map("user_id")
  displayName  String   @map("display_name")
  seed         Int?
  status       String   @default("active")
  createdAt    DateTime @default(now()) @map("created_at")

  tournament       Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  user            User?      @relation(fields: [userId], references: [id])
  members         TournamentParticipantMember[]
  groupMembers     GroupMember[]
  matchSideMembers MatchSideMember[]
  groupStandings   GroupStanding[]

  @@unique([tournamentId, displayName])
  @@index([userId])
  @@map("tournament_participants")
}

model TournamentParticipantMember {
  tournamentParticipantId String   @map("tournament_participant_id") @db.Uuid
  userId                  String   @map("user_id")
  createdAt               DateTime @default(now()) @map("created_at")

  tournamentParticipant TournamentParticipant @relation(fields: [tournamentParticipantId], references: [id], onDelete: Cascade)
  user                  User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([tournamentParticipantId, userId])
  @@index([userId])
  @@map("tournament_participant_members")
}

model Stage {
  id           String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tournamentId String    @map("tournament_id") @db.Uuid
  name         String
  type         StageType
  stageOrder   Int       @map("stage_order")
  createdAt    DateTime  @default(now()) @map("created_at")

  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  groups     Group[]
  matches    Match[]
  stageRules StageRule?
  drawSessions DrawSession[]

  @@map("stages")
}

model Group {
  id         String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  stageId    String  @map("stage_id") @db.Uuid
  name       String
  groupOrder Int?    @map("group_order")

  stage        Stage          @relation(fields: [stageId], references: [id], onDelete: Cascade)
  members      GroupMember[]
  matches      Match[]
  standings    GroupStanding[]
  bracketSlots BracketSlot[]
  drawAssignments DrawGroupAssignment[]

  @@unique([stageId, name])
  @@map("groups")
}

model GroupMember {
  groupId                 String @map("group_id") @db.Uuid
  tournamentParticipantId String @map("tournament_participant_id") @db.Uuid
  seedInGroup             Int?   @map("seed_in_group")
  status                  String @default("active")

  group                 Group                 @relation(fields: [groupId], references: [id], onDelete: Cascade)
  tournamentParticipant TournamentParticipant @relation(fields: [tournamentParticipantId], references: [id], onDelete: Cascade)

  @@id([groupId, tournamentParticipantId])
  @@map("group_members")
}

model Match {
  id        String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  stageId   String      @map("stage_id") @db.Uuid
  groupId   String?     @map("group_id") @db.Uuid
  roundNo   Int?        @map("round_no")
  matchNo   Int?        @map("match_no")
  bestOf    Int         @map("best_of")
  status    MatchStatus @default(SCHEDULED)
  createdAt DateTime    @default(now()) @map("created_at")

  stage              Stage         @relation(fields: [stageId], references: [id], onDelete: Cascade)
  group              Group?        @relation(fields: [groupId], references: [id], onDelete: Cascade)
  sides              MatchSide[]
  games              Game[]
  bracketSlotsTarget BracketSlot[] @relation("BracketSlotTarget")
  bracketSlotsSource BracketSlot[] @relation("BracketSlotSource")

  @@map("matches")
}

model MatchSide {
  id             String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  matchId        String         @map("match_id") @db.Uuid
  side           MatchSideLabel
  isWinner       Boolean?       @map("is_winner")
  walkoverReason String?        @map("walkover_reason")

  match   Match             @relation(fields: [matchId], references: [id], onDelete: Cascade)
  members MatchSideMember[]

  @@unique([matchId, side])
  @@map("match_sides")
}

model MatchSideMember {
  matchSideId             String @map("match_side_id") @db.Uuid
  tournamentParticipantId String @map("tournament_participant_id") @db.Uuid

  matchSide             MatchSide             @relation(fields: [matchSideId], references: [id], onDelete: Cascade)
  tournamentParticipant TournamentParticipant @relation(fields: [tournamentParticipantId], references: [id])

  @@id([matchSideId, tournamentParticipantId])
  @@map("match_side_members")
}

model Game {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  matchId    String   @map("match_id") @db.Uuid
  gameNo     Int      @map("game_no")
  scoreA     Int      @map("score_a")
  scoreB     Int      @map("score_b")
  finishedAt DateTime? @map("finished_at")

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@unique([matchId, gameNo])
  @@map("games")
}

model StageRule {
  id                    String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  stageId               String   @map("stage_id") @db.Uuid
  winPoints             Int      @default(1) @map("win_points")
  lossPoints            Int      @default(0) @map("loss_points")
  byePoints             Int      @default(1) @map("bye_points")
  countByeGamesPoints   Boolean  @default(false) @map("count_bye_games_points")
  countWalkoverAsPlayed Boolean  @default(true) @map("count_walkover_as_played")
  tieBreakOrder         Json     @map("tie_break_order")
  h2hMode               H2hMode  @map("h2h_mode")
  createdAt             DateTime @default(now()) @map("created_at")

  stage Stage @relation(fields: [stageId], references: [id], onDelete: Cascade)

  @@unique([stageId])
  @@map("stage_rules")
}

model StageRulePreset {
  id                   String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  code                 String         @unique
  name                 String
  description          String?
  winPoints            Int            @default(1) @map("win_points")
  lossPoints           Int            @default(0) @map("loss_points")
  byePoints            Int            @default(1) @map("bye_points")
  countByeGamesPoints  Boolean        @default(false) @map("count_bye_games_points")
  countWalkoverAsPlayed Boolean       @default(true) @map("count_walkover_as_played")
  tieBreakOrder        Json           @map("tie_break_order")
  h2hMode              H2hMode        @map("h2h_mode")
  qualifyMode          QualifyMode    @default(TOP_N_PER_GROUP) @map("qualify_mode")
  topNPerGroup         Int?           @map("top_n_per_group")
  topNOverall          Int?           @map("top_n_overall")
  wildcardCount        Int            @default(0) @map("wildcard_count")
  isActive             Boolean        @default(true) @map("is_active")
  createdAt            DateTime       @default(now()) @map("created_at")

  @@index([isActive, createdAt])
  @@map("stage_rule_presets")
}

model GroupStanding {
  groupId                 String   @map("group_id") @db.Uuid
  tournamentParticipantId String   @map("tournament_participant_id") @db.Uuid
  rank                    Int?
  matchPoints             Int?     @map("match_points")
  matchesWon              Int?     @map("matches_won")
  matchesLost             Int?     @map("matches_lost")
  gamesWon                Int?     @map("games_won")
  gamesLost               Int?     @map("games_lost")
  pointsWon               Int?     @map("points_won")
  pointsLost              Int?     @map("points_lost")
  note                    String?
  updatedAt               DateTime @default(now()) @map("updated_at")

  group                 Group                 @relation(fields: [groupId], references: [id], onDelete: Cascade)
  tournamentParticipant TournamentParticipant @relation(fields: [tournamentParticipantId], references: [id], onDelete: Cascade)

  @@id([groupId, tournamentParticipantId])
  @@map("group_standings")
}

model BracketSlot {
  id            String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  targetMatchId String            @map("target_match_id") @db.Uuid
  targetSide    MatchSideLabel    @map("target_side")
  sourceType    BracketSourceType @map("source_type")
  sourceMatchId String?           @map("source_match_id") @db.Uuid
  sourceGroupId String?           @map("source_group_id") @db.Uuid
  sourceRank    Int?              @map("source_rank")
  sourceSeed    Int?              @map("source_seed")
  createdAt     DateTime          @default(now()) @map("created_at")

  targetMatch Match  @relation("BracketSlotTarget", fields: [targetMatchId], references: [id], onDelete: Cascade)
  sourceMatch Match? @relation("BracketSlotSource", fields: [sourceMatchId], references: [id], onDelete: Cascade)
  sourceGroup Group? @relation(fields: [sourceGroupId], references: [id], onDelete: Cascade)

  @@unique([targetMatchId, targetSide])
  @@map("bracket_slots")
}

model DrawSession {
  id           String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tournamentId String     @map("tournament_id") @db.Uuid
  stageId      String?    @map("stage_id") @db.Uuid
  type         DrawType
  status       DrawStatus @default(DRAFT)
  payload      Json
  result       Json
  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @updatedAt @map("updated_at")

  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  stage      Stage?     @relation(fields: [stageId], references: [id], onDelete: Cascade)
  pairings   DrawPairing[]
  groupAssignments DrawGroupAssignment[]

  @@index([tournamentId, type, createdAt])
  @@map("draw_sessions")
}

model DrawPairing {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  drawSessionId String   @map("draw_session_id") @db.Uuid
  sideAId       String   @map("side_a_id")
  sideBId       String?  @map("side_b_id")
  order         Int
  createdAt     DateTime @default(now()) @map("created_at")

  drawSession DrawSession @relation(fields: [drawSessionId], references: [id], onDelete: Cascade)

  @@index([drawSessionId, order])
  @@map("draw_pairings")
}

model DrawGroupAssignment {
  drawSessionId           String @map("draw_session_id") @db.Uuid
  groupId                 String @map("group_id") @db.Uuid
  tournamentParticipantId String @map("tournament_participant_id") @db.Uuid
  seedInGroup             Int?   @map("seed_in_group")

  drawSession DrawSession @relation(fields: [drawSessionId], references: [id], onDelete: Cascade)
  group       Group       @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@id([drawSessionId, groupId, tournamentParticipantId])
  @@map("draw_group_assignments")
}

enum StageType {
  GROUP    @map("group")
  KNOCKOUT @map("knockout")

  @@map("stage_type")
}

enum MatchFormat {
  SINGLE
  DOUBLES
}

enum MatchStatus {
  SCHEDULED @map("scheduled")
  IN_PROGRESS @map("in_progress")
  COMPLETED @map("completed")
  CANCELLED @map("cancelled")

  @@map("match_status")
}

enum MatchSideLabel {
  A @map("A")
  B @map("B")

  @@map("match_side_label")
}

enum H2hMode {
  TWO_WAY_ONLY @map("two_way_only")
  MINI_TABLE   @map("mini_table")

  @@map("h2h_mode")
}

enum QualifyMode {
  TOP_N_PER_GROUP @map("top_n_per_group")
  TOP_N_OVERALL   @map("top_n_overall")
  CUSTOM          @map("custom")

  @@map("qualify_mode")
}

enum BracketSourceType {
  MATCH_WINNER @map("match_winner")
  GROUP_RANK   @map("group_rank")
  SEED         @map("seed")

  @@map("bracket_source_type")
}

enum DrawType {
  DOUBLES_PAIRING
  GROUP_ASSIGNMENT
  KNOCKOUT_PAIRING
}

enum DrawStatus {
  DRAFT
  APPLIED
  CANCELLED
}

// ============================================
// JOBS & QUEUES (for future migration)
// ============================================
// Uncomment when needed for job tracking

// model Job {
//   id          String    @id @default(cuid())
//   name        String
//   data        Json
//   status      JobStatus @default(PENDING)
//   progress    Int       @default(0)
//   result      Json?
//   error       String?
//   attempts    Int       @default(0)
//   maxAttempts Int       @default(3) @map("max_attempts")
//   scheduledAt DateTime? @map("scheduled_at")
//   startedAt   DateTime? @map("started_at")
//   completedAt DateTime? @map("completed_at")
//   createdAt   DateTime  @default(now()) @map("created_at")
//   updatedAt   DateTime  @updatedAt @map("updated_at")
//   
//   @@map("jobs")
//   @@index([status])
//   @@index([name])
// }

// enum JobStatus {
//   PENDING
//   PROCESSING
//   COMPLETED
//   FAILED
//   CANCELLED
// }
